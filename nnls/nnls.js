// Generated by CoffeeScript 1.12.4
(function() {
  var buildReferences, plotConfigObject, testspectrum, updateConstraints, updateDcnv, updateReferences;

  Array.prototype.t = function() {
    var m, n, o, p, r, ref, ref1;
    if (this.dim() === 2) {
      r = xoes([this.size(1), this.size(0)], 0/0);
      for (m = o = 0, ref = this.size(0); 0 <= ref ? o < ref : o > ref; m = 0 <= ref ? ++o : --o) {
        for (n = p = 0, ref1 = this.size(1); 0 <= ref1 ? p < ref1 : p > ref1; n = 0 <= ref1 ? ++p : --p) {
          r[n][m] = this[m][n];
        }
      }
      return r;
    } else if (this.dim() === 1) {
      return this.map(function(x) {
        return [x];
      });
    }
  };

  Array.prototype.size = function(a) {
    if (a == null) {
      a = -1;
    }
    if (a === -1) {
      return numeric.dim(this);
    } else {
      return numeric.dim(this)[a];
    }
  };

  Array.prototype.dim = function() {
    return numeric.dim(this).length;
  };

  Array.prototype.dot = function(b) {
    return numeric.dot(this, b);
  };

  Array.prototype.max = function() {
    var i, m, o, ref, t;
    if (this.dim() > 1) {
      t = this.map(function(x) {
        return x.max();
      });
      return t.max();
    }
    m = this[0];
    for (i = o = 0, ref = this.length; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      if (this[i] > m) {
        m = this[i];
      }
    }
    return m;
  };

  Array.prototype.min = function() {
    var i, m, o, ref, t;
    if (this.dim() > 1) {
      t = this.map(function(x) {
        return x.max();
      });
      return t.max();
    }
    m = this[0];
    for (i = o = 0, ref = this.length; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      if (this[i] < m) {
        m = this[i];
      }
    }
    return m;
  };

  Array.prototype.argmax = function() {
    var i, m, o, ref;
    if (this.dim() !== 1) {
      throw "can only calculate argmax for 1D-arrays";
    }
    m = this.max();
    for (i = o = 0, ref = this.length; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      if (this[i] === m) {
        return i;
      }
    }
  };

  Array.prototype.select = function(m, n) {
    var i, o, r, ref;
    if (m instanceof Array) {
      if (n instanceof Array) {
        if (this.size()[0] !== m.length || this.size()[1] !== n.length) {
          throw "dimensions do not match: input: " + this.size()[0] + "," + this.size()[1] + ", m-array:" + m.length + " n-array:" + n.length;
        }
        return this.select(m).t().select(n).t();
      } else {
        if (this.size()[0] !== m.length) {
          throw "dimensions do not match: input: " + this.size()[0] + ", m-array:" + m.length;
        }
        r = [];
        for (i = o = 0, ref = m.length; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
          if (m[i]) {
            r.push(this[i]);
          }
        }
        return r;
      }
    } else {
      if (n instanceof Array) {
        if (this.size()[1] !== n.length) {
          throw "dimensions do not match: input: " + this.size()[1] + " n-array: " + n.length;
        }
        return this.t().select(n).t();
      } else {
        return [];
      }
    }
  };

  Array.prototype.set = function(x, m, n) {
    var i, j, o, p, q, ref, ref1, ref2, ref3, u;
    if (m instanceof Array) {
      if (n instanceof Array) {
        if (this.size()[0] !== m.length || this.size()[1] !== n.length) {
          throw "dimensions do not match: target: " + this.size()[0] + "," + this.size()[1] + " m-vector: " + m.length + " n-vector: " + n.length;
        }
        if (x.size()[0] !== m.length || x.size()[1] !== n.length) {
          throw "dimensions do not match: source: " + x.size()[0] + "," + x.size()[1] + " m-vector: " + m.length + " n-vector: " + n.length;
        }
        for (i = o = 0, ref = m.length; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
          for (j = p = 0, ref1 = m.length; 0 <= ref1 ? p < ref1 : p > ref1; j = 0 <= ref1 ? ++p : --p) {
            if (m[i] && n[j]) {
              this[i][j] = x[i][j];
            }
          }
        }
        return this;
      } else {
        if (this.size()[0] !== m.length) {
          throw "dimensions do not match: target: " + this.size()[0] + " m-vector: " + m.length;
        }
        if (x.size()[0] !== m.length) {
          throw "dimensions do not match: source: " + x.size()[0] + " m-vector: " + m.length;
        }
        for (i = q = 0, ref2 = m.length; 0 <= ref2 ? q < ref2 : q > ref2; i = 0 <= ref2 ? ++q : --q) {
          if (m[i]) {
            this[i] = x[i];
          }
        }
        return this;
      }
    } else {
      if (n instanceof Array) {
        if (this.size()[1] !== n.length) {
          throw "dimensions do not match: target: " + this.size()[1] + " n-vector: " + n.length;
        }
        if (x.size()[1] !== n.length) {
          throw "dimensions do not match: source: " + x.size()[1] + " n-vector: " + n.length;
        }
        this.set(this.t().set(x.t(), n).t());
        return this;
      } else {
        for (i = u = 0, ref3 = this.size()[0]; 0 <= ref3 ? u < ref3 : u > ref3; i = 0 <= ref3 ? ++u : --u) {
          this[i] = x[i];
        }
        return this;
      }
    }
  };

  Array.prototype.not = function() {
    if (this.dim() !== 1) {
      throw "can only bool inverse 1D arrays";
    }
    return this.map(function(x) {
      return !x;
    });
  };

  Array.prototype.check1D = function(x) {
    if (this.dim() !== 1 || x.dim() !== 1) {
      throw "can only use 1D arrays";
    }
    if (this.length !== x.length) {
      throw "arrays dont have same length";
    }
  };

  this.xoes = function(x, y) {
    var i, o, p, r, ref, ref1;
    if (!(x instanceof Array)) {
      x = [x];
    }
    r = [];
    if (x.length > 1) {
      for (i = o = 0, ref = x[0]; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
        r.push(xoes(x.slice(1), y));
      }
      return r;
    }
    for (i = p = 0, ref1 = x[0]; 0 <= ref1 ? p < ref1 : p > ref1; i = 0 <= ref1 ? ++p : --p) {
      r.push(y);
    }
    return r;
  };

  this.zeros = function(x) {
    return xoes(x, 0);
  };

  this.ones = function(x) {
    return xoes(x, 1);
  };

  this.falses = function(x) {
    return xoes(x, false);
  };

  this.trues = function(x) {
    return xoes(x, true);
  };

  Array.prototype.check = function(x, fun) {
    if (!(x instanceof Array)) {
      x = xoes(this.size(), x);
    }
    this.check1D(x);
    return this.map(fun, x);
  };

  Array.prototype.and = function(x) {
    return this.check(x, function(cV, i) {
      return cV && this[i];
    });
  };

  Array.prototype.or = function(x) {
    return this.check(x, function(cV, i) {
      return cV || this[i];
    });
  };

  Array.prototype.lt = function(x) {
    return this.check(x, function(cV, i) {
      return cV < this[i];
    });
  };

  Array.prototype.lteq = function(x) {
    return this.check(x, function(cV, i) {
      return cV <= this[i];
    });
  };

  Array.prototype.gt = function(x) {
    return this.check(x, function(cV, i) {
      return cV > this[i];
    });
  };

  Array.prototype.gteq = function(x) {
    return this.check(x, function(cV, i) {
      return cV >= this[i];
    });
  };

  Array.prototype.add = function(x) {
    return this.check(x, function(cV, i) {
      return cV + this[i];
    });
  };

  Array.prototype.sub = function(x) {
    return this.check(x, function(cV, i) {
      return cV - this[i];
    });
  };

  Array.prototype.mul = function(x) {
    return this.check(x, function(cV, i) {
      return cV * this[i];
    });
  };

  Array.prototype.div = function(x) {
    return this.check(x, function(cV, i) {
      return cV / this[i];
    });
  };

  Array.prototype.pow = function(x) {
    return this.check(x, function(cV, i) {
      return Math.pow(cV, this[i]);
    });
  };

  Array.prototype.mod = function(x) {
    return this.check(x, function(cV, i) {
      return cV % this[i];
    });
  };

  Array.prototype.pinv = function() {
    var M, S, Sinv, U, V, i, m, n, o, ref, tol, z;
    z = numeric.svd(this);
    U = z.U;
    S = z.S;
    V = z.V;
    m = this.length;
    n = this[0].length;
    tol = Math.max(m, n) * numeric.epsilon * z.S[0];
    M = S.length;
    Sinv = new Array(M);
    for (i = o = ref = M - 1; ref <= 0 ? o <= 0 : o >= 0; i = ref <= 0 ? ++o : --o) {
      if (S[i] > tol) {
        Sinv[i] = 1 / S[i];
      } else {
        Sinv[i] = 0;
      }
    }
    return U.dot(numeric.diag(Sinv)).dot(V.t());
  };

  Array.prototype.sum = function() {
    var s;
    if (this.dim() > 1) {
      return this.map(function(x) {
        return x.sum();
      }).sum();
    } else {
      s = 0;
      this.map(function(x) {
        return s += x;
      });
      return s;
    }
  };

  Array.prototype.ithTrue = function(i) {
    var j, k, o, ref;
    if (this.dim() > 1) {
      throw "ithTrue only works with one dimension";
    }
    j = 0;
    for (k = o = 0, ref = this.length; 0 <= ref ? o < ref : o > ref; k = 0 <= ref ? ++o : --o) {
      if (this[k]) {
        if (j === i) {
          return k;
        } else {
          j += 1;
        }
      }
    }
    return null;
  };

  this.nnls = function(Z, x, tol) {
    var P, ZP, ZPT, alpha, d, i, itercount, j, m, maxiter, n, o, p, ref, ref1, s, sp, w;
    if (tol == null) {
      tol = 1e-8;
    }
    n = Z.size(0);
    P = falses(n);
    d = zeros(n);
    w = Z.dot(x.sub(Z.t().dot(d)));
    maxiter = 30 * n;
    itercount = 0;
    while (P.sum() < n && w.select(P.not()).gt(tol).sum()) {
      itercount += 1;
      m = P.not().ithTrue(w.select(P.not()).argmax());
      P[m] = true;
      s = zeros(n);
      ZP = Z.select(P);
      ZPT = Z.select(P).t();
      sp = ZP.dot(ZPT).pinv().dot(ZP).dot(x);
      j = 0;
      for (i = o = 0, ref = P.length; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
        if (P[i]) {
          s[i] = sp[j];
          j += 1;
        }
      }
      while (sp.min() < 0) {
        alpha = -1 * (d.select(P).div(sp.sub(d.select(P))).min());
        d = d.add(s.sub(d).mul(alpha));
        P = P.and(d.gt(tol));
        s = zeros(n);
        ZP = Z.select(P);
        ZPT = Z.select(P).t();
        sp = ZP.dot(ZPT).pinv().dot(ZP).dot(x);
        j = 0;
        for (i = p = 0, ref1 = P.length; 0 <= ref1 ? p < ref1 : p > ref1; i = 0 <= ref1 ? ++p : --p) {
          if (P[i]) {
            s[i] = sp[j];
            j += 1;
          }
        }
      }
      d = s;
      w = Z.dot(x.sub(Z.t().dot(d)));
      if (s[m] < tol) {
        break;
      }
      if (itercount > maxiter) {
        break;
      }
    }
    return d;
  };

  this.calcSpectrum = function(Z, d) {
    return Z.t().dot(d);
  };

  this.residueVector = function(Z, x, d) {
    return x.sub(calcSpectrum(Z, d));
  };

  this.residue = function(Z, x, d) {
    return Math.sqrt(residueVector(Z, x, d).pow(2).sum());
  };

  this.Spectrum = (function() {
    Spectrum.load = function(url) {
      var a;
      a = new Spectrum();
      a.loaded = false;
      $.get(url, null, function(response, status, jqXHR) {
        if (status === 'success') {
          return a.parseCSV(response);
        } else {
          throw "Could not load file " + url;
        }
      });
      return a;
    };

    Spectrum.names = {};

    Spectrum.selected = {};

    Spectrum.loadNames = function(callback) {
      var selection;
      if (typeof Storage !== "undefined") {
        selection = JSON.parse(localStorage.getItem('references'));
      }
      console.log(selection);
      if (typeof selection !== "object" || selection === null) {
        selection = {};
      }
      if (Object.keys(this.names).length === 0) {
        return $.getJSON({
          url: "refspectra.json",
          cache: false
        }, function(response, status, jqXHR) {
          var i, len, o, p, ref, results;
          if (status === 'success') {
            Spectrum.names = response.referenceSpectra;
            ref = Object.keys(Spectrum.names);
            for (o = 0, len = ref.length; o < len; o++) {
              i = ref[o];
              Spectrum.names[i].spectrum = Spectrum.load(Spectrum.names[i].url);
              if (typeof selection[i] === "boolean") {
                Spectrum.names[i].selected = selection[i];
              }
            }
            Spectrum.names['Precipitate'] = {
              selected: typeof selection[i] === "boolean" ? selection[i] : true,
              url: "",
              spectrum: Spectrum([
                (function() {
                  results = [];
                  for (p = 200; p <= 800; p++){ results.push(p); }
                  return results;
                }).apply(this), ones(601).mul(0.01)
              ]),
              color: "#999999"
            };
            return callback(Spectrum.names);
          } else {
            return console.log("ERROR: Could not load refspectra.json (Default reference spectrum settings");
          }
        });
      }
    };

    function Spectrum(data) {
      var a;
      if (data instanceof Array) {
        if (data.dim() !== 2) {
          throw "invalid input data for spectrum: not a 2D array";
        }
        if (data.length !== 2) {
          data = data.t();
        }
        if (data.length !== 2) {
          throw "invalid input data for spectrum: not two columns given";
        }
        a = new Spectrum();
        a.loaded = false;
        a.loadArrays(data[0], data[1]);
        return a;
      }
      if (typeof data === "string" || data instanceof String) {
        a = new Spectrum();
        a.loaded = false;
        a.parseCSV(data);
        return a;
      }
    }

    Spectrum.prototype.loadArrays = function(wl, ext) {
      var i, o, ref;
      this.data = {};
      for (i = o = 0, ref = wl.length; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
        this.data[Math.round(wl[i])] = ext[i];
      }
      this.wlmin = Math.round(wl.min());
      this.wlmax = Math.round(wl.max());
      this.wlstep = (this.wlmax - this.wlmin) / (wl.length - 1);
      this.extmin = ext.min();
      this.extmax = ext.max();
      if (this.extmax > 2) {
        this.extmax = 2;
      }
      return this.loaded = true;
    };

    Spectrum.prototype.makeCSV = function() {
      var csvContent;
      csvContent = "data:txt/csv;charset=utf-8,Wavelength (nm),Extinction\n";
      $.each(this.data, function(x, y) {
        return csvContent += x + "," + y + "\n";
      });
      return csvContent;
    };

    Spectrum.prototype.parseCSV = function(data) {
      var conc, ext, l, len, lines, o, res, wl;
      lines = data.split("\r\n");
      if (lines.length < 2) {
        lines = data.split("\n");
      }
      if (lines.length < 2) {
        lines = data.split("\r");
      }
      if (lines.length < 2) {
        throw "invalid input data: no lines detected: " + data;
      }
      wl = [];
      ext = [];
      conc = 1;
      if (lines.length > 2) {
        res = lines[1].match(/^conc:\s(\d+[\.,]?\d*)/i);
        if (res) {
          conc = parseFloat(res[1]);
        }
      }
      for (o = 0, len = lines.length; o < len; o++) {
        l = lines[o];
        res = l.match(/^\s*"?(-?\d+\.?\d*)"?\s*[,;]\s*"?(-?\d+\.?\d*)"?/);
        if (res) {
          wl.push(parseFloat(res[1]));
          ext.push(parseFloat(res[2]));
        } else if (res === null && wl.length) {
          break;
        }
      }
      if (wl.length === ext.length && wl.length > 0) {
        if (conc !== 1) {
          ext = ext.div(conc);
        }
      }
      return this.loadArrays(wl, ext);
    };

    Spectrum.prototype.plotData = function(conc, wlmin, wlmax) {
      var data, i, lasti, len, o, ref;
      if (conc == null) {
        conc = 1;
      }
      data = [];
      ref = Object.keys(this.data).sort();
      for (o = 0, len = ref.length; o < len; o++) {
        i = ref[o];
        if (i < wlmin) {
          continue;
        }
        if (i > wlmax) {
          continue;
        }
        data.push({
          x: i,
          y: this.data[i] * conc
        });
        lasti = i;
      }
      return data;
    };

    Spectrum.prototype.interpolateWL = function(wl) {
      var r, rc, rf;
      wl = Math.round(wl);
      if (this.data[wl] !== null) {
        return this.data[wl];
      }
      if (wl < this.wlmin) {
        return 0/0;
      }
      if (wl > this.wlmax) {
        return 0/0;
      }
      r = (wl - this.wlmin) / this.wlstep;
      rf = Math.floor(r) * this.wlstep + this.wlmin;
      rc = Math.ceil(r) * this.wlstep + this.wlmin;
      r = r % 1;
      return this.data[rf] * (1 - r) + this.data[rc] * r;
    };

    Spectrum.prototype.wl = function(wlmin, wlmax, wlstep) {
      var len, max, min, o, p, r, ref, ref1, wl;
      if (wlmax == null) {
        wlmax = null;
      }
      if (wlstep == null) {
        wlstep = null;
      }
      if (wlmax !== null) {
        if (wlstep === null) {
          wlstep = 1;
        }
        min = wlmin / wlstep;
        max = wlmax / wlstep;
        r = [];
        for (wl = o = ref = min, ref1 = max; ref <= ref1 ? o <= ref1 : o >= ref1; wl = ref <= ref1 ? ++o : --o) {
          r.push(wl * wlstep);
        }
        return this.wl(r);
      }
      if (wlmin instanceof Array) {
        r = [];
        for (p = 0, len = wlmin.length; p < len; p++) {
          wl = wlmin[p];
          r.push(this.interpolateWL(wl));
        }
        return r;
      }
      if (typeof wlmin === "number") {
        return this.interpolateWL(wlmin);
      }
    };

    Spectrum.prototype.dcnv = function(min, max, step) {
      var a, cS, i, names, o, p, q, rV, ref, ref1, ref2, ref3, ref4, ref_matrix, refs, res, sol, x_vector;
      if (min == null) {
        min = null;
      }
      if (max == null) {
        max = null;
      }
      if (step == null) {
        step = null;
      }
      refs = [];
      names = [];
      a = this.dcnv;
      $.each(Spectrum.names, function(name, value) {
        if (value.selBox.is(':checked')) {
          names.push(name);
          return refs.push(value.spectrum);
        }
      });
      if (refs.length < 1) {
        console.log("no dncv with less than two spectra selected");
        return null;
      }
      if (min === null) {
        min = $.map(refs, function(x) {
          return x.wlmin;
        });
        min = [min.max(), this.wlmin].max();
        if (Spectrum.constraints.min.constraint > 0) {
          min = [Spectrum.constraints.min.constraint, min].max();
        }
      }
      if (max === null) {
        max = $.map(refs, function(x) {
          return x.wlmax;
        });
        max = [max.min(), this.wlmax].min();
        if (Spectrum.constraints.max.constraint > 0) {
          max = [Spectrum.constraints.max.constraint, max].min();
        }
      }
      if (step === null) {
        step = $.map(refs, function(x) {
          return x.wlstep;
        });
        step = [step.max(), this.wlstep].max();
        if (Spectrum.constraints.step.constraint > 0) {
          step = [Spectrum.constraints.step.constraint, step].max();
        }
      }
      if (min >= max) {
        console.log("no dncv with min=" + min + ">max=" + max);
        return null;
      }
      ref_matrix = $.map(refs, function(x) {
        return [x.wl(min, max, step)];
      });
      x_vector = this.wl(min, max, step);
      sol = nnls(ref_matrix, x_vector);
      res = {
        'result': {},
        'residue': null,
        'residueVector': [],
        'params': {
          'min': min,
          'max': max,
          'step': step
        }
      };
      for (i = o = 0, ref = names.length; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
        res['result'][names[i]] = sol[i];
      }
      res['residue'] = residue(ref_matrix, x_vector, sol);
      cS = calcSpectrum(ref_matrix, sol);
      res['extmax'] = [cS.max(), x_vector.max()].max();
      rV = residueVector(ref_matrix, x_vector, sol);
      res['calcSpectrum'] = [];
      for (i = p = ref1 = max / step, ref2 = min / step; ref1 <= ref2 ? p <= ref2 : p >= ref2; i = ref1 <= ref2 ? ++p : --p) {
        res['calcSpectrum'].push({
          x: i * step,
          y: cS.pop()
        });
      }
      res['residueVector'] = [];
      for (i = q = ref3 = max / step, ref4 = min / step; ref3 <= ref4 ? q <= ref4 : q >= ref4; i = ref3 <= ref4 ? ++q : --q) {
        res['residueVector'].push({
          x: i * step,
          y: rV.pop()
        });
      }
      return res;
    };

    return Spectrum;

  })();

  testspectrum = null;

  plotConfigObject = function(wlmin, wlmax) {
    return {
      data: {
        datasets: [
          {
            label: 'Sample',
            pointRadius: 0,
            data: testspectrum.plotData(1, wlmin, wlmax),
            fill: false,
            backgroundColor: 'black',
            borderColor: 'black',
            borderWidth: 2
          }
        ]
      },
      options: {
        title: {
          display: true,
          text: 'Deconvoluted Spectrum'
        },
        scales: {
          xAxes: [
            {
              ticks: {
                min: Spectrum.constraints.min.constraint ? Spectrum.constraints.min.constraint : testspectrum.wlmin,
                max: Spectrum.constraints.max.constraint ? Spectrum.constraints.max.constraint : testspectrum.wlmax
              }
            }
          ],
          yAxes: [
            {
              ticks: {
                min: 0,
                max: testspectrum.extmax * 1.1
              }
            }
          ]
        }
      }
    };
  };

  updateDcnv = function() {
    var c, cC, d, i, len, len1, o, p, ref, ref1, res, v;
    if (!(testspectrum instanceof Spectrum)) {
      return;
    }
    ref = Object.keys(Spectrum.names);
    for (o = 0, len = ref.length; o < len; o++) {
      i = ref[o];
      if (!Spectrum.names[i].spectrum.loaded) {
        setTimeout(f, 100);
        console.log("not all references loaded, trying again in 100ms");
        return;
      }
    }
    if (!testspectrum.loaded) {
      setTimeout(f, 100);
      console.log("testspectrum not loaded, trying again in 100ms");
      return;
    }
    cC = $('#canvas_container');
    cC.empty();
    c = $('<canvas>');
    cC.append(c);
    c[0].style.width = '100%';
    c[0].style.height = '100%';
    c[0].width = c.offsetWidth;
    c[0].height = c.offsetHeight;
    res = testspectrum.dcnv();
    if (res) {
      d = plotConfigObject(res.params.min, res.params.max);
    } else {
      d = plotConfigObject(testspectrum.wlmin, testspectrum.wlmax);
    }
    ref1 = Object.keys(Spectrum.names);
    for (p = 0, len1 = ref1.length; p < len1; p++) {
      i = ref1[p];
      if (res) {
        v = res.result[i];
      }
      if (typeof v === "number") {
        Spectrum.names[i].valueCell.html(v.toFixed(4));
        d.data.datasets.push({
          label: i + " (" + v.toFixed(2) + "µM)",
          pointRadius: 0,
          data: Spectrum.names[i].spectrum.plotData(v, res.params.min, res.params.max),
          fill: false,
          backgroundColor: Spectrum.names[i].color,
          borderColor: Spectrum.names[i].color,
          borderWidth: 1
        });
      } else {
        Spectrum.names[i].valueCell.html('');
      }
    }
    if (res.extmax) {
      d.options.scales.yAxes[0].ticks.max = Math.ceil(res.extmax * 5.1) / 5;
    }
    if (res && res.calcSpectrum) {
      d.data.datasets.push({
        label: "Calculated Spectrum",
        data: res.calcSpectrum,
        pointRadius: 0,
        fill: false,
        backgroundColor: "#ff0000",
        borderColor: "#ff0000",
        borderWidth: 2
      });
    }
    if (res) {
      Spectrum.constraints.min.text.val(res.params.min);
    }
    if (res) {
      Spectrum.constraints.max.text.val(res.params.max);
    }
    if (res) {
      Spectrum.constraints.step.text.val(res.params.step);
    }
    if (res && typeof res.residue === "number") {
      Spectrum.residue.html(res.residue.toFixed(3));
    } else {
      Spectrum.residue.html('');
    }
    return c = Chart.Scatter(c[0].getContext("2d"), d);
  };

  updateConstraints = function(evt) {
    var i, len, o, persistentConstraint, ref, v;
    persistentConstraint = {};
    ref = Object.keys(Spectrum.constraints);
    for (o = 0, len = ref.length; o < len; o++) {
      i = ref[o];
      v = parseFloat(Spectrum.constraints[i].text.val());
      if (Spectrum.constraints[i].check.is(':checked')) {
        Spectrum.constraints[i].constraint = v;
      } else {
        Spectrum.constraints[i].constraint = 0/0;
      }
      if (isNaN(v)) {
        Spectrum.constraints[i].text.val('auto');
      } else {
        Spectrum.constraints[i].text.val(v.toFixed(0));
      }
      persistentConstraint[i] = {
        constraint: Spectrum.constraints[i].constraint
      };
    }
    if (typeof Storage !== "undefined") {
      localStorage.setItem('constraints', JSON.stringify(persistentConstraint));
    }
    return updateDcnv();
  };

  updateReferences = function() {
    var i, len, o, ref, selected;
    updateDcnv();
    if (typeof Storage !== "undefined") {
      selected = {};
      ref = Object.keys(Spectrum.names);
      for (o = 0, len = ref.length; o < len; o++) {
        i = ref[o];
        selected[i] = Spectrum.names[i].selBox.is(':checked');
        if (selected[i]) {
          Spectrum.names[i].selBox.parent().parent().removeClass('deselectedRow');
        } else {
          Spectrum.names[i].selBox.parent().parent().addClass('deselectedRow');
        }
      }
      return localStorage.setItem('references', JSON.stringify(selected));
    }
  };

  buildReferences = function() {
    var cb, i, len, len1, o, p, rB, ref, ref1, table, tbody, td, tr;
    rB = $('#referenceBox');
    rB.empty();
    table = $('<table class="table table-sm">');
    table.append($('<thead><tr><th class="firstCol">&nbsp;</th><th>Substance</th><th>Conc (µM)</th></tr></thead>'));
    rB.append(table);
    tbody = $('<tbody>');
    table.append(tbody);
    ref = Object.keys(Spectrum.names);
    for (o = 0, len = ref.length; o < len; o++) {
      i = ref[o];
      if (!Spectrum.names[i].spectrum.loaded) {
        rB.append('<div class="alert alert-danger">Waiting for reference spectra to load...</div>');
        setTimeout(buildReferences, 100);
        console.log("Spectrum " + i + " not yet loaded, trying again in 100ms");
        return;
      }
      tr = $('<tr>');
      tbody.append(tr);
      td = $('<td class="firstCol">');
      tr.append(td);
      if (Spectrum.names[i].selected) {
        cb = $("<input type=\"checkbox\" checked=\"checked\"/>");
      } else {
        cb = $("<input type=\"checkbox\" />");
        tr.addClass('deselectedRow');
      }
      Spectrum.names[i].selBox = cb;
      td.append(cb);
      cb.data('ref', i);
      cb.change(updateReferences);
      td = $('<td>');
      tr.append(td);
      td.html(i);
      td = $('<td>');
      tr.append(td);
      Spectrum.names[i].valueCell = td;
    }
    if (typeof Spectrum.constraints !== "object" || Spectrum.constraints === null) {
      Spectrum.constraints = {
        min: {},
        max: {},
        step: {}
      };
    }
    ref1 = Object.keys(Spectrum.constraints);
    for (p = 0, len1 = ref1.length; p < len1; p++) {
      i = ref1[p];
      tr = $('<tr>');
      tbody.append(tr);
      td = $('<td class="firstCol">');
      cb = $("<input type=\"checkbox\">");
      Spectrum.constraints[i].check = cb;
      if (Spectrum.constraints[i].constraint > 0) {
        cb.attr('checked', 'checked');
      }
      cb.change(updateConstraints);
      td.append(cb);
      tr.append(td);
      tr.append($('<td>wavelength ' + i + '</td>'));
      td = $('<td>');
      tr.append(td);
      cb = $("<input type=\"text\" value=\"auto\" placeholder=\"auto\" size=\"6\">");
      if (Spectrum.constraints[i].constraint > 0) {
        cb.val(Spectrum.constraints[i].constraint.toFixed(0));
      }
      Spectrum.constraints[i].text = cb;
      cb.change(updateConstraints);
      td.append(cb);
    }
    Spectrum.residue = $('<td>');
    tr = $('<tr>');
    tbody.append(tr);
    tr.append('<td class="firstCol">&nbsp;</td>');
    tr.append('<td>Residue</td>');
    tr.append(Spectrum.residue);
    return updateDcnv();
  };

  $(function() {
    var e, fdz;
    if (typeof Storage !== "undefined") {
      Spectrum.constraints = JSON.parse(localStorage.getItem('constraints'));
    }
    Spectrum.loadNames(buildReferences);
    if (location.hash && location.hash.length > 10) {
      try {
        testspectrum = new Spectrum();
        testspectrum.parseCSV(atob(location.hash.substr(1)));
        if (!testspectrum.loaded) {
          throw "no valid string";
        }
        console.log("loaded test spectrum from url");
      } catch (error) {
        e = error;
        testspectrum = null;
        console.log("failed to read a base64 encoded string: " + e);
      }
    }
    fdz = document.getElementById("file_drop_zone");
    fdz.addEventListener('dragover', (function(evt) {
      evt.stopPropagation();
      evt.preventDefault();
      evt.dataTransfer.dropEffect = 'copy';
      return evt.dataTransfer.effectAllowed = 'copy';
    }), false);
    fdz.addEventListener('drop', (function(evt) {
      var dt, fi, reader;
      evt.stopPropagation();
      evt.preventDefault();
      dt = evt.dataTransfer;
      if (dt.files && dt.files.length > 0) {
        fi = dt.files[0];
        reader = new FileReader();
        reader.onload = function(evt) {
          try {
            testspectrum = new Spectrum();
            testspectrum.parseCSV(reader.result);
            return updateDcnv();
          } catch (error) {
            e = error;
            return alert("Failed to parse CSV for dropped file " + fi.name + ": " + e);
          }
        };
        reader.readAsText(fi);
      }
    }), false);
    fdz.addEventListener('dragend', (function(evt) {
      var dt, i, o, ref, results;
      dt = evt.dataTransfer;
      if (dt.items) {
        results = [];
        for (i = o = 0, ref = dt.items.length; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
          results.push(dt.items.remove(i));
        }
        return results;
      } else {
        return evt.dataTransfer.clearData();
      }
    }), false);
    return fdz.addEventListener('click', (function(evt) {
      var link;
      if (!(testspectrum instanceof Spectrum)) {
        return;
      }
      link = document.createElement('a');
      link.download = "spectrum.csv";
      link.href = encodeURI(testspectrum.makeCSV());
      return link.click();
    }), false);
  });

}).call(this);
